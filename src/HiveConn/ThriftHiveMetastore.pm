#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Types;
use Facebook::FB303::FacebookService;

# HELPER FUNCTIONS AND STRUCTURES

package ThriftHiveMetastore_create_database_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_create_database_args->mk_accessors( qw( database ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{database} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{database}) {
      $self->{database} = $vals->{database};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{database} = new Database();
        $xfer += $self->{database}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_args');
  if (defined $self->{database}) {
    $xfer += $output->writeFieldBegin('database', TType::STRUCT, 1);
    $xfer += $self->{database}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_create_database_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_create_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_database_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_database_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_database_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_database_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Database();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_database_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_database_args->mk_accessors( qw( name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_database_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new InvalidOperationException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_databases_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_databases_args->mk_accessors( qw( pattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pattern}) {
      $self->{pattern} = $vals->{pattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_databases_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{pattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_args');
  if (defined $self->{pattern}) {
    $xfer += $output->writeFieldBegin('pattern', TType::STRING, 1);
    $xfer += $output->writeString($self->{pattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_databases_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_databases_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_databases_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size101 = 0;
          $self->{success} = [];
          my $_etype104 = 0;
          $xfer += $input->readListBegin(\$_etype104, \$_size101);
          for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
          {
            my $elem106 = undef;
            $xfer += $input->readString(\$elem106);
            push(@{$self->{success}},$elem106);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter107 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter107);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_all_databases_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_databases_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_all_databases_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_all_databases_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_databases_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size108 = 0;
          $self->{success} = [];
          my $_etype111 = 0;
          $xfer += $input->readListBegin(\$_etype111, \$_size108);
          for (my $_i112 = 0; $_i112 < $_size108; ++$_i112)
          {
            my $elem113 = undef;
            $xfer += $input->readString(\$elem113);
            push(@{$self->{success}},$elem113);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter114 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter114);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_type_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_type_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_type_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Type();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_create_type_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_create_type_args->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{type} = new Type();
        $xfer += $self->{type}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_args');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRUCT, 1);
    $xfer += $self->{type}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_create_type_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_create_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_type_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_type_args->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_args');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_type_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_type_all_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_type_all_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_all_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_type_all_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_type_all_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_all_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size115 = 0;
          $self->{success} = {};
          my $_ktype116 = 0;
          my $_vtype117 = 0;
          $xfer += $input->readMapBegin(\$_ktype116, \$_vtype117, \$_size115);
          for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
          {
            my $key120 = '';
            my $val121 = new Type();
            $xfer += $input->readString(\$key120);
            $val121 = new Type();
            $xfer += $val121->read($input);
            $self->{success}->{$key120} = $val121;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter122,$viter123) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter122);
          $xfer += ${viter123}->write($output);
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_fields_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_fields_args->mk_accessors( qw( db_name table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_fields_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_fields_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_fields_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_fields_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size124 = 0;
          $self->{success} = [];
          my $_etype127 = 0;
          $xfer += $input->readListBegin(\$_etype127, \$_size124);
          for (my $_i128 = 0; $_i128 < $_size124; ++$_i128)
          {
            my $elem129 = undef;
            $elem129 = new FieldSchema();
            $xfer += $elem129->read($input);
            push(@{$self->{success}},$elem129);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new UnknownTableException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter130 (@{$self->{success}}) 
        {
          $xfer += ${iter130}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_schema_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_schema_args->mk_accessors( qw( db_name table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_schema_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size131 = 0;
          $self->{success} = [];
          my $_etype134 = 0;
          $xfer += $input->readListBegin(\$_etype134, \$_size131);
          for (my $_i135 = 0; $_i135 < $_size131; ++$_i135)
          {
            my $elem136 = undef;
            $elem136 = new FieldSchema();
            $xfer += $elem136->read($input);
            push(@{$self->{success}},$elem136);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new UnknownTableException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter137 (@{$self->{success}}) 
        {
          $xfer += ${iter137}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_create_table_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_create_table_args->mk_accessors( qw( tbl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tbl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tbl}) {
      $self->{tbl} = $vals->{tbl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tbl} = new Table();
        $xfer += $self->{tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_args');
  if (defined $self->{tbl}) {
    $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
    $xfer += $self->{tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_create_table_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_create_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  $self->{o4} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
    if (defined $vals->{o4}) {
      $self->{o4} = $vals->{o4};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o4} = new NoSuchObjectException();
        $xfer += $self->{o4}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o4}) {
    $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
    $xfer += $self->{o4}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_table_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_table_args->mk_accessors( qw( dbname name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_table_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_tables_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_tables_args->mk_accessors( qw( db_name pattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{pattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{pattern}) {
      $self->{pattern} = $vals->{pattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{pattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{pattern}) {
    $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
    $xfer += $output->writeString($self->{pattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_tables_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size138 = 0;
          $self->{success} = [];
          my $_etype141 = 0;
          $xfer += $input->readListBegin(\$_etype141, \$_size138);
          for (my $_i142 = 0; $_i142 < $_size138; ++$_i142)
          {
            my $elem143 = undef;
            $xfer += $input->readString(\$elem143);
            push(@{$self->{success}},$elem143);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter144 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter144);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_all_tables_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_all_tables_args->mk_accessors( qw( db_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_all_tables_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_all_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size145 = 0;
          $self->{success} = [];
          my $_etype148 = 0;
          $xfer += $input->readListBegin(\$_etype148, \$_size145);
          for (my $_i149 = 0; $_i149 < $_size145; ++$_i149)
          {
            my $elem150 = undef;
            $xfer += $input->readString(\$elem150);
            push(@{$self->{success}},$elem150);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter151 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter151);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_table_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_table_args->mk_accessors( qw( dbname tbl_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_table_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_table_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Table();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_alter_table_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_alter_table_args->mk_accessors( qw( dbname tbl_name new_tbl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  $self->{new_tbl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_tbl}) {
      $self->{new_tbl} = $vals->{new_tbl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_tbl} = new Table();
        $xfer += $self->{new_tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_tbl}) {
    $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
    $xfer += $self->{new_tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_alter_table_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_alter_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_add_partition_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_add_partition_args->mk_accessors( qw( new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_args');
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_add_partition_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_add_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_append_partition_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_append_partition_args->mk_accessors( qw( db_name tbl_name part_vals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size152 = 0;
          $self->{part_vals} = [];
          my $_etype155 = 0;
          $xfer += $input->readListBegin(\$_etype155, \$_size152);
          for (my $_i156 = 0; $_i156 < $_size152; ++$_i156)
          {
            my $elem157 = undef;
            $xfer += $input->readString(\$elem157);
            push(@{$self->{part_vals}},$elem157);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter158 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter158);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_append_partition_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_append_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_append_partition_by_name_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_append_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_append_partition_by_name_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_append_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_partition_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_partition_args->mk_accessors( qw( db_name tbl_name part_vals deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size159 = 0;
          $self->{part_vals} = [];
          my $_etype162 = 0;
          $xfer += $input->readListBegin(\$_etype162, \$_size159);
          for (my $_i163 = 0; $_i163 < $_size159; ++$_i163)
          {
            my $elem164 = undef;
            $xfer += $input->readString(\$elem164);
            push(@{$self->{part_vals}},$elem164);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter165 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter165);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_partition_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_partition_by_name_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_drop_partition_by_name_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_drop_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_args->mk_accessors( qw( db_name tbl_name part_vals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size166 = 0;
          $self->{part_vals} = [];
          my $_etype169 = 0;
          $xfer += $input->readListBegin(\$_etype169, \$_size166);
          for (my $_i170 = 0; $_i170 < $_size166; ++$_i170)
          {
            my $elem171 = undef;
            $xfer += $input->readString(\$elem171);
            push(@{$self->{part_vals}},$elem171);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter172 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter172);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_by_name_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_by_name_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partitions_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partitions_args->mk_accessors( qw( db_name tbl_name max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partitions_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partitions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size173 = 0;
          $self->{success} = [];
          my $_etype176 = 0;
          $xfer += $input->readListBegin(\$_etype176, \$_size173);
          for (my $_i177 = 0; $_i177 < $_size173; ++$_i177)
          {
            my $elem178 = undef;
            $elem178 = new Partition();
            $xfer += $elem178->read($input);
            push(@{$self->{success}},$elem178);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter179 (@{$self->{success}}) 
        {
          $xfer += ${iter179}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_names_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_names_args->mk_accessors( qw( db_name tbl_name max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_names_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size180 = 0;
          $self->{success} = [];
          my $_etype183 = 0;
          $xfer += $input->readListBegin(\$_etype183, \$_size180);
          for (my $_i184 = 0; $_i184 < $_size180; ++$_i184)
          {
            my $elem185 = undef;
            $xfer += $input->readString(\$elem185);
            push(@{$self->{success}},$elem185);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter186 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter186);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partitions_ps_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partitions_ps_args->mk_accessors( qw( db_name tbl_name part_vals max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size187 = 0;
          $self->{part_vals} = [];
          my $_etype190 = 0;
          $xfer += $input->readListBegin(\$_etype190, \$_size187);
          for (my $_i191 = 0; $_i191 < $_size187; ++$_i191)
          {
            my $elem192 = undef;
            $xfer += $input->readString(\$elem192);
            push(@{$self->{part_vals}},$elem192);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter193 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter193);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partitions_ps_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partitions_ps_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size194 = 0;
          $self->{success} = [];
          my $_etype197 = 0;
          $xfer += $input->readListBegin(\$_etype197, \$_size194);
          for (my $_i198 = 0; $_i198 < $_size194; ++$_i198)
          {
            my $elem199 = undef;
            $elem199 = new Partition();
            $xfer += $elem199->read($input);
            push(@{$self->{success}},$elem199);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter200 (@{$self->{success}}) 
        {
          $xfer += ${iter200}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_names_ps_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_names_ps_args->mk_accessors( qw( db_name tbl_name part_vals max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_ps_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size201 = 0;
          $self->{part_vals} = [];
          my $_etype204 = 0;
          $xfer += $input->readListBegin(\$_etype204, \$_size201);
          for (my $_i205 = 0; $_i205 < $_size201; ++$_i205)
          {
            my $elem206 = undef;
            $xfer += $input->readString(\$elem206);
            push(@{$self->{part_vals}},$elem206);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter207 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter207);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_partition_names_ps_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_partition_names_ps_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_ps_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size208 = 0;
          $self->{success} = [];
          my $_etype211 = 0;
          $xfer += $input->readListBegin(\$_etype211, \$_size208);
          for (my $_i212 = 0; $_i212 < $_size208; ++$_i212)
          {
            my $elem213 = undef;
            $xfer += $input->readString(\$elem213);
            push(@{$self->{success}},$elem213);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter214 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter214);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_alter_partition_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_alter_partition_args->mk_accessors( qw( db_name tbl_name new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_alter_partition_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_alter_partition_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_config_value_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_config_value_args->mk_accessors( qw( name defaultValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{defaultValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{defaultValue}) {
      $self->{defaultValue} = $vals->{defaultValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_config_value_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{defaultValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultValue}) {
    $xfer += $output->writeFieldBegin('defaultValue', TType::STRING, 2);
    $xfer += $output->writeString($self->{defaultValue});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_get_config_value_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_get_config_value_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_config_value_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new ConfigValSecurityException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_partition_name_to_vals_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_partition_name_to_vals_args->mk_accessors( qw( part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_vals_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_args');
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_partition_name_to_vals_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_partition_name_to_vals_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_vals_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size215 = 0;
          $self->{success} = [];
          my $_etype218 = 0;
          $xfer += $input->readListBegin(\$_etype218, \$_size215);
          for (my $_i219 = 0; $_i219 < $_size215; ++$_i219)
          {
            my $elem220 = undef;
            $xfer += $input->readString(\$elem220);
            push(@{$self->{success}},$elem220);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter221 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter221);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_partition_name_to_spec_args;
use base qw(Class::Accessor);
ThriftHiveMetastore_partition_name_to_spec_args->mk_accessors( qw( part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_spec_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_args');
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastore_partition_name_to_spec_result;
use base qw(Class::Accessor);
ThriftHiveMetastore_partition_name_to_spec_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_spec_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size222 = 0;
          $self->{success} = {};
          my $_ktype223 = 0;
          my $_vtype224 = 0;
          $xfer += $input->readMapBegin(\$_ktype223, \$_vtype224, \$_size222);
          for (my $_i226 = 0; $_i226 < $_size222; ++$_i226)
          {
            my $key227 = '';
            my $val228 = '';
            $xfer += $input->readString(\$key227);
            $xfer += $input->readString(\$val228);
            $self->{success}->{$key227} = $val228;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter229,$viter230) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter229);
          $xfer += $output->writeString($viter230);
        }
      }
      $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHiveMetastoreIf;

use strict;
use base qw(Facebook::FB303::FacebookServiceIf);

sub create_database{
  my $self = shift;
  my $database = shift;

  die 'implement interface';
}

sub get_database{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_databases{
  my $self = shift;
  my $pattern = shift;

  die 'implement interface';
}

sub get_all_databases{
  my $self = shift;

  die 'implement interface';
}

sub get_type{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub create_type{
  my $self = shift;
  my $type = shift;

  die 'implement interface';
}

sub drop_type{
  my $self = shift;
  my $type = shift;

  die 'implement interface';
}

sub get_type_all{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub create_table{
  my $self = shift;
  my $tbl = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

  die 'implement interface';
}

sub get_all_tables{
  my $self = shift;
  my $db_name = shift;

  die 'implement interface';
}

sub get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

  die 'implement interface';
}

sub alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

  die 'implement interface';
}

sub add_partition{
  my $self = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  die 'implement interface';
}

sub append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  die 'implement interface';
}

sub get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

  die 'implement interface';
}

sub partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

  die 'implement interface';
}

package ThriftHiveMetastoreRest;

use strict;
use base qw(Facebook::FB303::FacebookServiceRest);

sub create_database{
  my ($self, $request) = @_;

  my $database = ($request->{'database'}) ? $request->{'database'} : undef;
  return $self->{impl}->create_database($database);
}

sub get_database{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_database($name);
}

sub drop_database{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_database($name, $deleteData);
}

sub get_databases{
  my ($self, $request) = @_;

  my $pattern = ($request->{'pattern'}) ? $request->{'pattern'} : undef;
  return $self->{impl}->get_databases($pattern);
}

sub get_all_databases{
  my ($self, $request) = @_;

  return $self->{impl}->get_all_databases();
}

sub get_type{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_type($name);
}

sub create_type{
  my ($self, $request) = @_;

  my $type = ($request->{'type'}) ? $request->{'type'} : undef;
  return $self->{impl}->create_type($type);
}

sub drop_type{
  my ($self, $request) = @_;

  my $type = ($request->{'type'}) ? $request->{'type'} : undef;
  return $self->{impl}->drop_type($type);
}

sub get_type_all{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_type_all($name);
}

sub get_fields{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_fields($db_name, $table_name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema($db_name, $table_name);
}

sub create_table{
  my ($self, $request) = @_;

  my $tbl = ($request->{'tbl'}) ? $request->{'tbl'} : undef;
  return $self->{impl}->create_table($tbl);
}

sub drop_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_table($dbname, $name, $deleteData);
}

sub get_tables{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $pattern = ($request->{'pattern'}) ? $request->{'pattern'} : undef;
  return $self->{impl}->get_tables($db_name, $pattern);
}

sub get_all_tables{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  return $self->{impl}->get_all_tables($db_name);
}

sub get_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  return $self->{impl}->get_table($dbname, $tbl_name);
}

sub alter_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_tbl = ($request->{'new_tbl'}) ? $request->{'new_tbl'} : undef;
  return $self->{impl}->alter_table($dbname, $tbl_name, $new_tbl);
}

sub add_partition{
  my ($self, $request) = @_;

  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->add_partition($new_part);
}

sub append_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  return $self->{impl}->append_partition($db_name, $tbl_name, $part_vals);
}

sub append_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->append_partition_by_name($db_name, $tbl_name, $part_name);
}

sub drop_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
}

sub drop_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
}

sub get_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  return $self->{impl}->get_partition($db_name, $tbl_name, $part_vals);
}

sub get_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->get_partition_by_name($db_name, $tbl_name, $part_name);
}

sub get_partitions{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions($db_name, $tbl_name, $max_parts);
}

sub get_partition_names{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partition_names($db_name, $tbl_name, $max_parts);
}

sub get_partitions_ps{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
}

sub get_partition_names_ps{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
}

sub alter_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->alter_partition($db_name, $tbl_name, $new_part);
}

sub get_config_value{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $defaultValue = ($request->{'defaultValue'}) ? $request->{'defaultValue'} : undef;
  return $self->{impl}->get_config_value($name, $defaultValue);
}

sub partition_name_to_vals{
  my ($self, $request) = @_;

  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->partition_name_to_vals($part_name);
}

sub partition_name_to_spec{
  my ($self, $request) = @_;

  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->partition_name_to_spec($part_name);
}

package ThriftHiveMetastoreClient;

use base qw(Facebook::FB303::FacebookServiceClient);
use base qw(ThriftHiveMetastoreIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self = $classname->SUPER::new($input, $output);
  return bless($self,$classname);
}

sub create_database{
  my $self = shift;
  my $database = shift;

    $self->send_create_database($database);
  $self->recv_create_database();
}

sub send_create_database{
  my $self = shift;
  my $database = shift;

  $self->{output}->writeMessageBegin('create_database', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_create_database_args();
  $args->{database} = $database;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_create_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_database{
  my $self = shift;
  my $name = shift;

    $self->send_get_database($name);
  return $self->recv_get_database();
}

sub send_get_database{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_database', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_database_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_database failed: unknown result";
}
sub drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;

    $self->send_drop_database($name, $deleteData);
  $self->recv_drop_database();
}

sub send_drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_database', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_drop_database_args();
  $args->{name} = $name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_drop_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_databases{
  my $self = shift;
  my $pattern = shift;

    $self->send_get_databases($pattern);
  return $self->recv_get_databases();
}

sub send_get_databases{
  my $self = shift;
  my $pattern = shift;

  $self->{output}->writeMessageBegin('get_databases', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_databases_args();
  $args->{pattern} = $pattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_databases{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_databases_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_databases failed: unknown result";
}
sub get_all_databases{
  my $self = shift;

    $self->send_get_all_databases();
  return $self->recv_get_all_databases();
}

sub send_get_all_databases{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_all_databases', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_all_databases_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_databases{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_all_databases_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_all_databases failed: unknown result";
}
sub get_type{
  my $self = shift;
  my $name = shift;

    $self->send_get_type($name);
  return $self->recv_get_type();
}

sub send_get_type{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_type', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_type_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_type failed: unknown result";
}
sub create_type{
  my $self = shift;
  my $type = shift;

    $self->send_create_type($type);
  return $self->recv_create_type();
}

sub send_create_type{
  my $self = shift;
  my $type = shift;

  $self->{output}->writeMessageBegin('create_type', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_create_type_args();
  $args->{type} = $type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_create_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "create_type failed: unknown result";
}
sub drop_type{
  my $self = shift;
  my $type = shift;

    $self->send_drop_type($type);
  return $self->recv_drop_type();
}

sub send_drop_type{
  my $self = shift;
  my $type = shift;

  $self->{output}->writeMessageBegin('drop_type', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_drop_type_args();
  $args->{type} = $type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_drop_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_type failed: unknown result";
}
sub get_type_all{
  my $self = shift;
  my $name = shift;

    $self->send_get_type_all($name);
  return $self->recv_get_type_all();
}

sub send_get_type_all{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_type_all', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_type_all_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_type_all{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_type_all_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_type_all failed: unknown result";
}
sub get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

    $self->send_get_fields($db_name, $table_name);
  return $self->recv_get_fields();
}

sub send_get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_fields', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_fields_args();
  $args->{db_name} = $db_name;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_fields{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_fields_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_fields failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

    $self->send_get_schema($db_name, $table_name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_schema_args();
  $args->{db_name} = $db_name;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_schema failed: unknown result";
}
sub create_table{
  my $self = shift;
  my $tbl = shift;

    $self->send_create_table($tbl);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $tbl = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_create_table_args();
  $args->{tbl} = $tbl;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  if (defined $result->{o4}) {
    die $result->{o4};
  }
  return;
}
sub drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

    $self->send_drop_table($dbname, $name, $deleteData);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_drop_table_args();
  $args->{dbname} = $dbname;
  $args->{name} = $name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

    $self->send_get_tables($db_name, $pattern);
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_tables_args();
  $args->{db_name} = $db_name;
  $args->{pattern} = $pattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_tables failed: unknown result";
}
sub get_all_tables{
  my $self = shift;
  my $db_name = shift;

    $self->send_get_all_tables($db_name);
  return $self->recv_get_all_tables();
}

sub send_get_all_tables{
  my $self = shift;
  my $db_name = shift;

  $self->{output}->writeMessageBegin('get_all_tables', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_all_tables_args();
  $args->{db_name} = $db_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_all_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_all_tables failed: unknown result";
}
sub get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

    $self->send_get_table($dbname, $tbl_name);
  return $self->recv_get_table();
}

sub send_get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

  $self->{output}->writeMessageBegin('get_table', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_table_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_table failed: unknown result";
}
sub alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

    $self->send_alter_table($dbname, $tbl_name, $new_tbl);
  $self->recv_alter_table();
}

sub send_alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

  $self->{output}->writeMessageBegin('alter_table', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_alter_table_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->{new_tbl} = $new_tbl;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_alter_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub add_partition{
  my $self = shift;
  my $new_part = shift;

    $self->send_add_partition($new_part);
  return $self->recv_add_partition();
}

sub send_add_partition{
  my $self = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('add_partition', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_add_partition_args();
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_add_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_partition failed: unknown result";
}
sub append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

    $self->send_append_partition($db_name, $tbl_name, $part_vals);
  return $self->recv_append_partition();
}

sub send_append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  $self->{output}->writeMessageBegin('append_partition', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_append_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_append_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "append_partition failed: unknown result";
}
sub append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

    $self->send_append_partition_by_name($db_name, $tbl_name, $part_name);
  return $self->recv_append_partition_by_name();
}

sub send_append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_append_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_append_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "append_partition_by_name failed: unknown result";
}
sub drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

    $self->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
  return $self->recv_drop_partition();
}

sub send_drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_partition', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_drop_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_drop_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_partition failed: unknown result";
}
sub drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

    $self->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
  return $self->recv_drop_partition_by_name();
}

sub send_drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_drop_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_drop_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_partition_by_name failed: unknown result";
}
sub get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

    $self->send_get_partition($db_name, $tbl_name, $part_vals);
  return $self->recv_get_partition();
}

sub send_get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  $self->{output}->writeMessageBegin('get_partition', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition failed: unknown result";
}
sub get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

    $self->send_get_partition_by_name($db_name, $tbl_name, $part_name);
  return $self->recv_get_partition_by_name();
}

sub send_get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_by_name failed: unknown result";
}
sub get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

    $self->send_get_partitions($db_name, $tbl_name, $max_parts);
  return $self->recv_get_partitions();
}

sub send_get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_partitions_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_partitions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions failed: unknown result";
}
sub get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

    $self->send_get_partition_names($db_name, $tbl_name, $max_parts);
  return $self->recv_get_partition_names();
}

sub send_get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partition_names', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_partition_names_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_partition_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_names failed: unknown result";
}
sub get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

    $self->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
  return $self->recv_get_partitions_ps();
}

sub send_get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_partitions_ps_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_ps{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_partitions_ps_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_partitions_ps failed: unknown result";
}
sub get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

    $self->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
  return $self->recv_get_partition_names_ps();
}

sub send_get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_partition_names_ps_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_names_ps{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_partition_names_ps_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_partition_names_ps failed: unknown result";
}
sub alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

    $self->send_alter_partition($db_name, $tbl_name, $new_part);
  $self->recv_alter_partition();
}

sub send_alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('alter_partition', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_alter_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_alter_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

    $self->send_get_config_value($name, $defaultValue);
  return $self->recv_get_config_value();
}

sub send_get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

  $self->{output}->writeMessageBegin('get_config_value', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_get_config_value_args();
  $args->{name} = $name;
  $args->{defaultValue} = $defaultValue;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_config_value{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_get_config_value_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_config_value failed: unknown result";
}
sub partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

    $self->send_partition_name_to_vals($part_name);
  return $self->recv_partition_name_to_vals();
}

sub send_partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_partition_name_to_vals_args();
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_partition_name_to_vals{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_partition_name_to_vals_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "partition_name_to_vals failed: unknown result";
}
sub partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

    $self->send_partition_name_to_spec($part_name);
  return $self->recv_partition_name_to_spec();
}

sub send_partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHiveMetastore_partition_name_to_spec_args();
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_partition_name_to_spec{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHiveMetastore_partition_name_to_spec_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "partition_name_to_spec failed: unknown result";
}
package ThriftHiveMetastoreProcessor;

use strict;
use base qw(Facebook::FB303::FacebookServiceProcessor);

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_create_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_create_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_create_database_result();
    eval {
      $self->{handler}->create_database($args->database);
    }; if( UNIVERSAL::isa($@,'AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('create_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_database_result();
    eval {
      $result->{success} = $self->{handler}->get_database($args->name);
    }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_drop_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_drop_database_result();
    eval {
      $self->{handler}->drop_database($args->name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'InvalidOperationException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('drop_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_databases {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_databases_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_databases_result();
    eval {
      $result->{success} = $self->{handler}->get_databases($args->pattern);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_databases', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_all_databases {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_all_databases_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_all_databases_result();
    eval {
      $result->{success} = $self->{handler}->get_all_databases();
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_all_databases', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_type_result();
    eval {
      $result->{success} = $self->{handler}->get_type($args->name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_create_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_create_type_result();
    eval {
      $result->{success} = $self->{handler}->create_type($args->type);
    }; if( UNIVERSAL::isa($@,'AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('create_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_drop_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_drop_type_result();
    eval {
      $result->{success} = $self->{handler}->drop_type($args->type);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_type_all {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_type_all_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_type_all_result();
    eval {
      $result->{success} = $self->{handler}->get_type_all($args->name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_type_all', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_fields {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_fields_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_fields_result();
    eval {
      $result->{success} = $self->{handler}->get_fields($args->db_name, $args->table_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'UnknownTableException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_fields', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->db_name, $args->table_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'UnknownTableException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_create_table_result();
    eval {
      $self->{handler}->create_table($args->tbl);
    }; if( UNIVERSAL::isa($@,'AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
        }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o4} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_drop_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_drop_table_result();
    eval {
      $self->{handler}->drop_table($args->dbname, $args->name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_tables($args->db_name, $args->pattern);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_all_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_all_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_all_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_all_tables($args->db_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_all_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_table_result();
    eval {
      $result->{success} = $self->{handler}->get_table($args->dbname, $args->tbl_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_alter_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_alter_table_result();
    eval {
      $self->{handler}->alter_table($args->dbname, $args->tbl_name, $args->new_tbl);
    }; if( UNIVERSAL::isa($@,'InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_add_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_add_partition_result();
    eval {
      $result->{success} = $self->{handler}->add_partition($args->new_part);
    }; if( UNIVERSAL::isa($@,'InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_append_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_append_partition_result();
    eval {
      $result->{success} = $self->{handler}->append_partition($args->db_name, $args->tbl_name, $args->part_vals);
    }; if( UNIVERSAL::isa($@,'InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('append_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_append_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_append_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->append_partition_by_name($args->db_name, $args->tbl_name, $args->part_name);
    }; if( UNIVERSAL::isa($@,'InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('append_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_drop_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_drop_partition_result();
    eval {
      $result->{success} = $self->{handler}->drop_partition($args->db_name, $args->tbl_name, $args->part_vals, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_drop_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_drop_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->drop_partition_by_name($args->db_name, $args->tbl_name, $args->part_name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_partition_result();
    eval {
      $result->{success} = $self->{handler}->get_partition($args->db_name, $args->tbl_name, $args->part_vals);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_by_name($args->db_name, $args->tbl_name, $args->part_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_partitions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_partitions_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions($args->db_name, $args->tbl_name, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_partition_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_partition_names_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_names($args->db_name, $args->tbl_name, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_ps {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_partitions_ps_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_partitions_ps_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_ps($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_partitions_ps', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_names_ps {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_partition_names_ps_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_partition_names_ps_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_names_ps($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_partition_names_ps', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_alter_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_alter_partition_result();
    eval {
      $self->{handler}->alter_partition($args->db_name, $args->tbl_name, $args->new_part);
    }; if( UNIVERSAL::isa($@,'InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_config_value {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_get_config_value_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_get_config_value_result();
    eval {
      $result->{success} = $self->{handler}->get_config_value($args->name, $args->defaultValue);
    }; if( UNIVERSAL::isa($@,'ConfigValSecurityException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_config_value', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_partition_name_to_vals {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_partition_name_to_vals_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_partition_name_to_vals_result();
    eval {
      $result->{success} = $self->{handler}->partition_name_to_vals($args->part_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('partition_name_to_vals', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_partition_name_to_spec {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new ThriftHiveMetastore_partition_name_to_spec_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHiveMetastore_partition_name_to_spec_result();
    eval {
      $result->{success} = $self->{handler}->partition_name_to_spec($args->part_name);
    }; if( UNIVERSAL::isa($@,'MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('partition_name_to_spec', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
